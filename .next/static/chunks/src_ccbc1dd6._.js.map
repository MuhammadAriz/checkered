{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,8JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,OAAI,AAAD,EAAE;AACtB","debugId":null}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/CheckerPiece.tsx"],"sourcesContent":["'use client';\n\nimport type React from 'react';\nimport { cn } from '@/lib/utils';\nimport type { Piece, Position } from '@/types/checkers';\n\ninterface CheckerPieceProps {\n  piece: Piece;\n  position: Position;\n  isSelected: boolean;\n  onClick: (pos: Position) => void;\n}\n\nconst CheckerPiece: React.FC<CheckerPieceProps> = ({ piece, position, isSelected, onClick }) => {\n  const pieceColorClass = piece.player === 'dark' ? 'checker-piece-dark' : 'checker-piece-light';\n  const kingClass = piece.isKing ? 'checker-piece-king' : '';\n  const selectedClass = isSelected ? 'checker-piece-selected' : '';\n\n  const handleClick = () => {\n    onClick(position);\n  };\n\n  return (\n    <div\n      className={cn('checker-piece', pieceColorClass, kingClass, selectedClass)}\n      onClick={handleClick}\n      role=\"button\"\n      aria-label={`Checker piece at row ${position.row + 1}, column ${position.col + 1}, color ${piece.player}${piece.isKing ? ', king' : ''}`}\n      aria-pressed={isSelected}\n    >\n      {/* King indicator is handled by CSS ::after pseudo-element */}\n    </div>\n  );\n};\n\nexport default CheckerPiece;\n"],"names":[],"mappings":";;;;AAGA;AAHA;;;AAaA,MAAM,eAA4C,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE,OAAO,EAAE;IACzF,MAAM,kBAAkB,MAAM,MAAM,KAAK,SAAS,uBAAuB;IACzE,MAAM,YAAY,MAAM,MAAM,GAAG,uBAAuB;IACxD,MAAM,gBAAgB,aAAa,2BAA2B;IAE9D,MAAM,cAAc;QAClB,QAAQ;IACV;IAEA,qBACE,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iBAAiB,iBAAiB,WAAW;QAC3D,SAAS;QACT,MAAK;QACL,cAAY,CAAC,qBAAqB,EAAE,SAAS,GAAG,GAAG,EAAE,SAAS,EAAE,SAAS,GAAG,GAAG,EAAE,QAAQ,EAAE,MAAM,MAAM,GAAG,MAAM,MAAM,GAAG,WAAW,IAAI;QACxI,gBAAc;;;;;;AAKpB;KApBM;uCAsBS","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/BoardSquare.tsx"],"sourcesContent":["'use client';\n\nimport type React from 'react';\nimport { cn } from '@/lib/utils';\nimport type { BoardSquare as BoardSquareType, Position, Piece, Move } from '@/types/checkers';\nimport CheckerPiece from './CheckerPiece';\n\ninterface BoardSquareProps {\n  square: BoardSquareType;\n  position: Position;\n  isDark: boolean;\n  isSelected: boolean;\n  isValidMove: boolean;\n  onSquareClick: (pos: Position) => void;\n  onPieceClick: (pos: Position) => void;\n}\n\nconst BoardSquare: React.FC<BoardSquareProps> = ({\n  square,\n  position,\n  isDark,\n  isSelected,\n  isValidMove,\n  onSquareClick,\n  onPieceClick,\n}) => {\n  const squareColorClass = isDark ? 'board-square-dark' : 'board-square-light';\n  const highlightClass = isSelected ? 'board-square-highlight' : '';\n  const validMoveClass = isValidMove ? 'board-square-valid-move' : '';\n\n  const handleClick = () => {\n      if (!square) { // Clicked on an empty square\n          onSquareClick(position);\n      }\n      // Piece click is handled by the CheckerPiece component's onClick\n  };\n\n  return (\n    <div\n      className={cn('board-square', squareColorClass, highlightClass, validMoveClass)}\n      onClick={handleClick}\n      role=\"gridcell\"\n      aria-selected={isSelected}\n      aria-label={`Square at row ${position.row + 1}, column ${position.col + 1}, ${isDark ? 'dark' : 'light'}${square ? `, contains ${square.player} piece${square.isKing ? ' (king)' : ''}` : ', empty'}${isValidMove ? ', valid move target' : ''}`}\n    >\n      {square && (\n        <CheckerPiece\n          piece={square}\n          position={position}\n          isSelected={isSelected}\n          onClick={onPieceClick}\n        />\n      )}\n       {/* Valid move indicator is handled by CSS ::after pseudo-element */}\n    </div>\n  );\n};\n\nexport default BoardSquare;\n"],"names":[],"mappings":";;;;AAGA;AAEA;AALA;;;;AAiBA,MAAM,cAA0C,CAAC,EAC/C,MAAM,EACN,QAAQ,EACR,MAAM,EACN,UAAU,EACV,WAAW,EACX,aAAa,EACb,YAAY,EACb;IACC,MAAM,mBAAmB,SAAS,sBAAsB;IACxD,MAAM,iBAAiB,aAAa,2BAA2B;IAC/D,MAAM,iBAAiB,cAAc,4BAA4B;IAEjE,MAAM,cAAc;QAChB,IAAI,CAAC,QAAQ;YACT,cAAc;QAClB;IACA,iEAAiE;IACrE;IAEA,qBACE,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,gBAAgB,kBAAkB,gBAAgB;QAChE,SAAS;QACT,MAAK;QACL,iBAAe;QACf,cAAY,CAAC,cAAc,EAAE,SAAS,GAAG,GAAG,EAAE,SAAS,EAAE,SAAS,GAAG,GAAG,EAAE,EAAE,EAAE,SAAS,SAAS,UAAU,SAAS,CAAC,WAAW,EAAE,OAAO,MAAM,CAAC,MAAM,EAAE,OAAO,MAAM,GAAG,YAAY,IAAI,GAAG,YAAY,cAAc,wBAAwB,IAAI;kBAE/O,wBACC,6LAAC,qIAAA,CAAA,UAAY;YACX,OAAO;YACP,UAAU;YACV,YAAY;YACZ,SAAS;;;;;;;;;;;AAMnB;KAvCM;uCAyCS","debugId":null}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACvB,4VACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OAAO;YACP,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAC5B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO,EAAE;IACxD,MAAM,OAAO,UAAU,mKAAA,CAAA,OAAI,GAAG;IAC9B,qBACE,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,eAAe;YAAE;YAAS;YAAM;QAAU;QACxD,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,OAAO,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/alert.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,gBAAgB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACtB,6JACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,MAAM,sBAAQ,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAG3B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAO,EAAE,oBACnC,6LAAC;QACC,KAAK;QACL,MAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;;AAGb,MAAM,WAAW,GAAG;AAEpB,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,gDAAgD;QAC7D,GAAG,KAAK;;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,iCAAmB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,iBAAiB,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/checkersLogic.ts"],"sourcesContent":["import type { Piece, Player, Board, Position, Move, GameState } from '@/types/checkers';\n\nexport const BOARD_SIZE = 8;\n\n// Initialize the board with pieces in starting positions\nexport function initializeBoard(): Board {\n  const board: Board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      if ((row + col) % 2 !== 0) { // Only place pieces on dark squares\n        if (row < 3) {\n          board[row][col] = { player: 'dark', isKing: false };\n        } else if (row > 4) {\n          board[row][col] = { player: 'light', isKing: false };\n        }\n      }\n    }\n  }\n  return board;\n}\n\n// Check if a position is within the board boundaries\nexport function isWithinBoard(pos: Position): boolean {\n  return pos.row >= 0 && pos.row < BOARD_SIZE && pos.col >= 0 && pos.col < BOARD_SIZE;\n}\n\n// Check if a square is occupied by the opponent\nfunction isOpponent(board: Board, pos: Position, player: Player): boolean {\n  if (!isWithinBoard(pos)) return false;\n  const piece = board[pos.row][pos.col];\n  return piece !== null && piece.player !== player;\n}\n\n// Check if a square is empty\nfunction isEmpty(board: Board, pos: Position): boolean {\n   if (!isWithinBoard(pos)) return false;\n  return board[pos.row][pos.col] === null;\n}\n\n\n// Get possible moves for a piece (including captures)\nexport function getPossibleMoves(board: Board, from: Position, player: Player): Move[] {\n  const piece = board[from.row][from.col];\n  if (!piece || piece.player !== player) return [];\n\n  const moves: Move[] = [];\n  const captures: Move[] = [];\n  const directions = piece.isKing\n    ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] // King moves\n    : piece.player === 'light'\n    ? [[-1, -1], [-1, 1]] // Light normal moves (upwards)\n    : [[1, -1], [1, 1]]; // Dark normal moves (downwards)\n\n  // Check for captures first\n  for (const [dr, dc] of directions) {\n     const opponentPos = { row: from.row + dr, col: from.col + dc };\n     const landingPos = { row: from.row + 2 * dr, col: from.col + 2 * dc };\n\n     if (isWithinBoard(opponentPos) && isOpponent(board, opponentPos, player) && isWithinBoard(landingPos) && isEmpty(board, landingPos)) {\n        const capturedPiece = board[opponentPos.row][opponentPos.col];\n        if (capturedPiece) {\n           captures.push({ from, to: landingPos, captured: opponentPos });\n        }\n     }\n  }\n\n\n  // If captures are available, only capture moves are allowed\n   if (captures.length > 0) {\n     // Check for multi-captures recursively\n     const multiCaptures = checkMultiCaptures(board, from, player);\n     return multiCaptures.length > 0 ? multiCaptures : captures;\n   }\n\n   // If no captures, check for regular moves\n    for (const [dr, dc] of directions) {\n        const to = { row: from.row + dr, col: from.col + dc };\n        if (isWithinBoard(to) && isEmpty(board, to)) {\n           moves.push({ from, to });\n        }\n    }\n\n\n  return moves;\n}\n\n// Check for multi-jump possibilities recursively\nfunction checkMultiCaptures(board: Board, currentPos: Position, player: Player): Move[] {\n    const piece = board[currentPos.row]?.[currentPos.col]; // Add null check\n    if (!piece) return [];\n\n    const potentialCaptures: Move[] = [];\n    const directions = piece.isKing\n        ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]\n        : piece.player === 'light'\n        ? [[-1, -1], [-1, 1]]\n        : [[1, -1], [1, 1]];\n\n    for (const [dr, dc] of directions) {\n        const opponentPos = { row: currentPos.row + dr, col: currentPos.col + dc };\n        const landingPos = { row: currentPos.row + 2 * dr, col: currentPos.col + 2 * dc };\n\n        if (isWithinBoard(opponentPos) && isOpponent(board, opponentPos, player) && isWithinBoard(landingPos) && isEmpty(board, landingPos)) {\n            // Simulate the capture\n            const tempBoard = board.map(row => [...row]); // Deep copy\n            const movingPiece = tempBoard[currentPos.row][currentPos.col];\n            tempBoard[landingPos.row][landingPos.col] = movingPiece;\n            tempBoard[opponentPos.row][opponentPos.col] = null;\n            tempBoard[currentPos.row][currentPos.col] = null;\n\n            // Check for further captures from the landing position\n            const furtherCaptures = checkMultiCaptures(tempBoard, landingPos, player);\n\n            if (furtherCaptures.length > 0) {\n                // If further captures are possible, prepend the current capture to each path\n                furtherCaptures.forEach(fc => {\n                    potentialCaptures.push({\n                        from: currentPos,\n                        to: landingPos,\n                        captured: opponentPos,\n                        nextMoves: fc.nextMoves ? [fc] : [fc] // Ensure nextMoves is an array\n                    });\n                });\n            } else {\n                // This is the end of a capture sequence\n                potentialCaptures.push({ from: currentPos, to: landingPos, captured: opponentPos });\n            }\n        }\n    }\n\n    // We need to flatten the structure for the final list of possible starting moves\n    // This part is tricky. For the initial `getPossibleMoves` call, we only want the *first* jump.\n    // The UI will handle subsequent jumps based on the state after the first jump.\n    // So, let's just return the first-level captures found here.\n     const firstLevelCaptures = potentialCaptures.map(capture => ({\n        from: capture.from,\n        to: capture.to,\n        captured: capture.captured\n     }));\n\n     return firstLevelCaptures; // Return only the first jump possibilities from this position\n}\n\n\n// Apply a move to the board state\nexport function applyMove(board: Board, move: Move): Board {\n  const newBoard = board.map(row => [...row]); // Deep copy\n  const piece = newBoard[move.from.row][move.from.col];\n\n  if (!piece) return board; // Should not happen if move is valid\n\n  // Move the piece\n  newBoard[move.to.row][move.to.col] = piece;\n  newBoard[move.from.row][move.from.col] = null;\n\n  // Remove captured piece\n  if (move.captured) {\n    newBoard[move.captured.row][move.captured.col] = null;\n  }\n\n   // Check for crowning\n   const targetRow = piece.player === 'light' ? 0 : BOARD_SIZE - 1;\n   if (move.to.row === targetRow && !piece.isKing) {\n     newBoard[move.to.row][move.to.col] = { ...piece, isKing: true };\n   }\n\n\n  return newBoard;\n}\n\n\n// Check if a player has any possible moves left\nexport function hasMoves(board: Board, player: Player): boolean {\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (piece && piece.player === player) {\n        const moves = getPossibleMoves(board, { row: r, col: c }, player);\n        if (moves.length > 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// Check if a player has any pieces left\nexport function hasPieces(board: Board, player: Player): boolean {\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      if (board[r][c]?.player === player) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// Determine if the game is over and who won\nexport function checkWinner(board: Board, currentPlayer: Player): Player | 'draw' | null {\n    const opponent: Player = currentPlayer === 'light' ? 'dark' : 'light';\n\n    const currentPlayerHasMoves = hasMoves(board, currentPlayer);\n    const opponentHasMoves = hasMoves(board, opponent);\n    const currentPlayerHasPieces = hasPieces(board, currentPlayer);\n    const opponentHasPieces = hasPieces(board, opponent);\n\n\n    if (!currentPlayerHasPieces || !currentPlayerHasMoves) {\n        return opponent; // Current player cannot move or has no pieces, opponent wins\n    }\n    if (!opponentHasPieces || !opponentHasMoves) {\n        return currentPlayer; // Opponent cannot move or has no pieces, current player wins\n    }\n\n    // Draw condition (optional, e.g., based on move count without capture)\n    // For simplicity, we'll omit draw conditions for now.\n\n    return null; // Game is not over\n}\n\n\n// Check if any capture moves are available for the current player\nexport function mustCapture(board: Board, player: Player): boolean {\n   for (let r = 0; r < BOARD_SIZE; r++) {\n       for (let c = 0; c < BOARD_SIZE; c++) {\n           const piece = board[r][c];\n           if (piece && piece.player === player) {\n               const moves = getPossibleMoves(board, { row: r, col: c }, player);\n               if (moves.some(move => move.captured)) {\n                   return true;\n               }\n           }\n       }\n   }\n   return false;\n}\n\n// Get only the capture moves available for a player\nexport function getCaptureMoves(board: Board, player: Player): Move[] {\n    const captureMoves: Move[] = [];\n    for (let r = 0; r < BOARD_SIZE; r++) {\n        for (let c = 0; c < BOARD_SIZE; c++) {\n            const piece = board[r][c];\n            if (piece && piece.player === player) {\n                const moves = getPossibleMoves(board, { row: r, col: c }, player);\n                moves.forEach(move => {\n                    if (move.captured) {\n                        captureMoves.push(move);\n                    }\n                });\n            }\n        }\n    }\n    return captureMoves;\n}\n\n\n// Check if a specific piece has further captures available after a capture move\nexport function canContinueCapture(board: Board, pos: Position, player: Player): boolean {\n    const piece = board[pos.row][pos.col];\n    if (!piece || piece.player !== player) return false;\n\n    const directions = piece.isKing\n        ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]\n        : piece.player === 'light'\n        ? [[-1, -1], [-1, 1]]\n        : [[1, -1], [1, 1]];\n\n    for (const [dr, dc] of directions) {\n        const opponentPos = { row: pos.row + dr, col: pos.col + dc };\n        const landingPos = { row: pos.row + 2 * dr, col: pos.col + 2 * dc };\n\n        if (isWithinBoard(opponentPos) && isOpponent(board, opponentPos, player) && isWithinBoard(landingPos) && isEmpty(board, landingPos)) {\n           return true; // Found a possible next capture\n        }\n    }\n    return false;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 661, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/CheckersBoard.tsx"],"sourcesContent":["'use client';\n\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { RefreshCw, Undo } from 'lucide-react';\nimport BoardSquare from './BoardSquare';\nimport { Button } from '@/components/ui/button';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport type { Board, Position, Move, GameState, Player } from '@/types/checkers';\nimport {\n    initializeBoard,\n    getPossibleMoves,\n    applyMove,\n    checkWinner,\n    BOARD_SIZE,\n    mustCapture,\n    canContinueCapture,\n    getCaptureMoves\n} from '@/lib/checkersLogic';\nimport { cn } from '@/lib/utils';\n\nconst initialGameState: GameState = {\n  board: initializeBoard(),\n  currentPlayer: 'light',\n  selectedPiece: null,\n  possibleMoves: [],\n  winner: null,\n  isMultiCapture: false,\n  mustCapturePiece: null,\n};\n\nconst CheckersBoard: React.FC = () => {\n  const [gameState, setGameState] = useState<GameState>(initialGameState);\n  const [history, setHistory] = useState<GameState[]>([]); // For undo functionality\n\n   // Reset game to initial state\n   const resetGame = useCallback(() => {\n       setGameState(initialGameState);\n       setHistory([]);\n   }, []);\n\n  // Save current state to history\n   const saveHistory = useCallback((state: GameState) => {\n       setHistory(prev => [...prev, state]);\n   }, []);\n\n   // Undo the last move\n   const undoMove = useCallback(() => {\n       setHistory(prev => {\n           const lastState = prev.slice(0, -1); // Get all but the last state\n           const newState = lastState[lastState.length - 1] || initialGameState;\n           setGameState(newState); // Restore the previous state\n           return lastState;\n       });\n   }, []);\n\n\n  const handlePieceClick = useCallback((pos: Position) => {\n      const { board, currentPlayer, selectedPiece, isMultiCapture, mustCapturePiece } = gameState;\n      const piece = board[pos.row][pos.col];\n\n      // If in multi-capture mode, only the designated piece can be selected/moved\n      if (isMultiCapture && mustCapturePiece && (pos.row !== mustCapturePiece.row || pos.col !== mustCapturePiece.col)) {\n          return;\n      }\n\n      // Only allow clicking own pieces\n      if (!piece || piece.player !== currentPlayer) {\n        setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n        return;\n      }\n\n      // Check if a capture is mandatory\n      const captureIsMandatory = mustCapture(board, currentPlayer);\n      const availableMoves = getPossibleMoves(board, pos, currentPlayer);\n\n      // Filter moves: if capture is mandatory, only allow capture moves\n      const validMoves = captureIsMandatory\n          ? availableMoves.filter(move => move.captured)\n          : availableMoves;\n\n      // If clicking the same piece, deselect it (unless in multi-capture)\n      if (!isMultiCapture && selectedPiece && selectedPiece.row === pos.row && selectedPiece.col === pos.col) {\n          setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n      } else if (validMoves.length > 0) {\n           // If not mandatory capture, or if this piece has capture moves when mandatory\n          if (!captureIsMandatory || validMoves.some(m => m.from.row === pos.row && m.from.col === pos.col)) {\n              setGameState(prev => ({\n                  ...prev,\n                  selectedPiece: pos,\n                  possibleMoves: validMoves.filter(m => m.from.row === pos.row && m.from.col === pos.col) // Only show moves for this piece\n              }));\n          } else {\n             // Capture is mandatory, but this piece has no capture moves\n             setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n          }\n      } else {\n         // No valid moves for this piece\n         setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n      }\n\n  }, [gameState]);\n\n   const handleSquareClick = useCallback((pos: Position) => {\n       const { selectedPiece, possibleMoves, board, currentPlayer, isMultiCapture } = gameState;\n\n       if (!selectedPiece) return; // No piece selected\n\n       const move = possibleMoves.find(m => m.to.row === pos.row && m.to.col === pos.col);\n\n       if (move) {\n           saveHistory(gameState); // Save state before making the move\n\n           const newBoard = applyMove(board, move);\n           const wasCapture = !!move.captured;\n           let nextPlayer = currentPlayer === 'light' ? 'dark' : 'light';\n           let continueCapture = false;\n           let nextMustCapturePiece = null;\n\n           // Check for multi-capture possibility\n           if (wasCapture && canContinueCapture(newBoard, move.to, currentPlayer)) {\n               // Check if the *same player* MUST capture again from the new position\n               const furtherCaptures = getCaptureMoves(newBoard, currentPlayer).filter(m => m.from.row === move.to.row && m.from.col === move.to.col);\n               if (furtherCaptures.length > 0) {\n                  nextPlayer = currentPlayer; // Same player's turn again\n                  continueCapture = true;\n                  nextMustCapturePiece = move.to; // This piece must continue the capture\n               }\n           }\n\n           const winner = checkWinner(newBoard, nextPlayer);\n\n           setGameState({\n               board: newBoard,\n               currentPlayer: nextPlayer,\n               selectedPiece: continueCapture ? move.to : null, // Keep piece selected if multi-capture continues\n               possibleMoves: continueCapture ? getPossibleMoves(newBoard, move.to, currentPlayer).filter(m => m.captured) : [], // Only show capture moves if continuing\n               winner: winner,\n               isMultiCapture: continueCapture,\n               mustCapturePiece: nextMustCapturePiece,\n           });\n\n       } else {\n            // Clicked on an invalid square, deselect if not in multi-capture\n            if (!isMultiCapture) {\n               setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n            }\n       }\n   }, [gameState, saveHistory]);\n\n\n  useEffect(() => {\n    // Pre-calculate mandatory captures for the current player when their turn starts\n    if (!gameState.isMultiCapture && !gameState.winner) {\n        const captureIsMandatory = mustCapture(gameState.board, gameState.currentPlayer);\n        if (captureIsMandatory) {\n             // Optionally highlight pieces that MUST capture, or just enforce the rule.\n             // For simplicity, we'll just enforce the rule in handlePieceClick.\n             // We could potentially update possibleMoves here for all mandatory capture pieces.\n        }\n    }\n  }, [gameState.currentPlayer, gameState.board, gameState.isMultiCapture, gameState.winner]);\n\n\n  return (\n    <div className=\"flex flex-col items-center justify-center p-4 min-h-screen bg-background\">\n      <h1 className=\"text-3xl font-bold mb-4 text-foreground\">Checkered</h1>\n\n        {gameState.winner && (\n            <Alert variant={gameState.winner === 'draw' ? 'default' : 'default'} className=\"mb-4 bg-accent text-accent-foreground\">\n            <AlertTitle className=\"font-bold text-lg\">Game Over!</AlertTitle>\n            <AlertDescription>\n                {gameState.winner === 'draw' ? 'The game is a draw!' : `Player ${gameState.winner === 'light' ? 'Light (Gray)' : 'Dark (Red)'} wins!`}\n            </AlertDescription>\n            </Alert>\n        )}\n\n       {!gameState.winner && (\n            <div className=\"mb-4 text-lg font-semibold text-foreground\">\n            Turn:\n            <span className={cn(\"ml-2 px-2 py-1 rounded\", gameState.currentPlayer === 'light' ? 'bg-piece-light text-black' : 'bg-piece-dark text-white')}>\n                {gameState.currentPlayer === 'light' ? 'Light (Gray)' : 'Dark (Red)'}\n            </span>\n            {gameState.isMultiCapture && <span className=\"ml-2 text-sm text-destructive\">(Must complete capture)</span>}\n            </div>\n       )}\n\n\n      <div\n        className=\"grid grid-cols-8 border-4 border-gray-800 shadow-xl\"\n        style={{ width: 'fit-content' }}\n        role=\"grid\"\n        aria-label=\"Checkers board\"\n      >\n        {gameState.board.map((row, rowIndex) =>\n          row.map((square, colIndex) => {\n            const pos = { row: rowIndex, col: colIndex };\n            const isDark = (rowIndex + colIndex) % 2 !== 0;\n            const isSelected = gameState.selectedPiece?.row === rowIndex && gameState.selectedPiece?.col === colIndex;\n            const isValidMove = gameState.possibleMoves.some(move => move.to.row === rowIndex && move.to.col === colIndex);\n\n            return (\n              <BoardSquare\n                key={`${rowIndex}-${colIndex}`}\n                square={square}\n                position={pos}\n                isDark={isDark}\n                isSelected={isSelected}\n                isValidMove={isValidMove}\n                onSquareClick={handleSquareClick}\n                onPieceClick={handlePieceClick}\n              />\n            );\n          })\n        )}\n      </div>\n\n      <div className=\"mt-6 flex gap-4\">\n        <Button onClick={resetGame} variant=\"outline\">\n          <RefreshCw className=\"mr-2 h-4 w-4\" /> Reset Game\n        </Button>\n         <Button onClick={undoMove} variant=\"outline\" disabled={history.length === 0}>\n          <Undo className=\"mr-2 h-4 w-4\" /> Undo Move\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default CheckersBoard;\n"],"names":[],"mappings":"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","debugId":null}}]
}