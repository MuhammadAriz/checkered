{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,qIAAA,CAAA,OAAI,AAAD,EAAE;AACtB","debugId":null}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/CheckerPiece.tsx"],"sourcesContent":["\n'use client';\n\nimport type React from 'react';\nimport { cn } from '@/lib/utils';\nimport type { Piece, Position } from '@/types/checkers';\n\ninterface CheckerPieceProps {\n  piece: Piece;\n  position: Position;\n  isSelected: boolean;\n  isForcedToCapture?: boolean; // New prop\n  onClick: (pos: Position) => void;\n}\n\nconst CheckerPiece: React.FC<CheckerPieceProps> = ({ \n    piece, \n    position, \n    isSelected, \n    isForcedToCapture, // Destructure new prop\n    onClick \n}) => {\n  const pieceColorClass = piece.player === 'dark' ? 'checker-piece-dark' : 'checker-piece-light';\n  const kingClass = piece.isKing ? 'checker-piece-king' : '';\n  const selectedClass = isSelected ? 'checker-piece-selected' : '';\n  // Apply forced capture class only if it's forced and NOT already selected\n  const forcedCaptureClass = isForcedToCapture && !isSelected ? 'checker-piece-forced-capture' : '';\n\n\n  const handleClick = () => {\n    onClick(position);\n  };\n\n  return (\n    <div\n      className={cn(\n          'checker-piece', \n          pieceColorClass, \n          kingClass, \n          selectedClass, \n          forcedCaptureClass // Add new class\n        )}\n      onClick={handleClick}\n      role=\"button\"\n      aria-label={`Checker piece at row ${position.row + 1}, column ${position.col + 1}, color ${piece.player}${piece.isKing ? ', king' : ''}${isForcedToCapture ? ', must capture' : ''}`}\n      aria-pressed={isSelected}\n    >\n      {/* King indicator is handled by CSS ::after pseudo-element */}\n    </div>\n  );\n};\n\nexport default CheckerPiece;\n"],"names":[],"mappings":";;;;AAIA;AAHA;;;AAcA,MAAM,eAA4C,CAAC,EAC/C,KAAK,EACL,QAAQ,EACR,UAAU,EACV,iBAAiB,EACjB,OAAO,EACV;IACC,MAAM,kBAAkB,MAAM,MAAM,KAAK,SAAS,uBAAuB;IACzE,MAAM,YAAY,MAAM,MAAM,GAAG,uBAAuB;IACxD,MAAM,gBAAgB,aAAa,2BAA2B;IAC9D,0EAA0E;IAC1E,MAAM,qBAAqB,qBAAqB,CAAC,aAAa,iCAAiC;IAG/F,MAAM,cAAc;QAClB,QAAQ;IACV;IAEA,qBACE,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACR,iBACA,iBACA,WACA,eACA,mBAAmB,gBAAgB;;QAEvC,SAAS;QACT,MAAK;QACL,cAAY,CAAC,qBAAqB,EAAE,SAAS,GAAG,GAAG,EAAE,SAAS,EAAE,SAAS,GAAG,GAAG,EAAE,QAAQ,EAAE,MAAM,MAAM,GAAG,MAAM,MAAM,GAAG,WAAW,KAAK,oBAAoB,mBAAmB,IAAI;QACpL,gBAAc;;;;;;AAKpB;uCAEe","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/BoardSquare.tsx"],"sourcesContent":["\n'use client';\n\nimport type React from 'react';\nimport { cn } from '@/lib/utils';\nimport type { BoardSquare as BoardSquareType, Position, Piece, Move } from '@/types/checkers';\nimport CheckerPiece from './CheckerPiece';\n\ninterface BoardSquareProps {\n  square: BoardSquareType;\n  position: Position;\n  isDark: boolean;\n  isSelected: boolean;\n  isValidMove: boolean;\n  isForcedToCapture: boolean; // New prop\n  onSquareClick: (pos: Position) => void;\n  onPieceClick: (pos: Position) => void;\n}\n\nconst BoardSquare: React.FC<BoardSquareProps> = ({\n  square,\n  position,\n  isDark,\n  isSelected,\n  isValidMove,\n  isForcedToCapture, // Destructure new prop\n  onSquareClick,\n  onPieceClick,\n}) => {\n  const squareColorClass = isDark ? 'board-square-dark' : 'board-square-light';\n  const highlightClass = isSelected ? 'board-square-highlight' : '';\n  const validMoveClass = isValidMove ? 'board-square-valid-move' : '';\n\n  const handleClick = () => {\n      if (!square) { // Clicked on an empty square\n          onSquareClick(position);\n      }\n      // Piece click is handled by the CheckerPiece component's onClick\n  };\n\n  return (\n    <div\n      className={cn('board-square', squareColorClass, highlightClass, validMoveClass)}\n      onClick={handleClick}\n      role=\"gridcell\"\n      aria-selected={isSelected}\n      aria-label={`Square at row ${position.row + 1}, column ${position.col + 1}, ${isDark ? 'dark' : 'light'}${square ? `, contains ${square.player} piece${square.isKing ? ' (king)' : ''}` : ', empty'}${isValidMove ? ', valid move target' : ''}${isForcedToCapture && square ? ', mandatory capture piece' : ''}`}\n    >\n      {square && (\n        <CheckerPiece\n          piece={square}\n          position={position}\n          isSelected={isSelected}\n          isForcedToCapture={isForcedToCapture} // Pass down\n          onClick={onPieceClick}\n        />\n      )}\n       {/* Valid move indicator is handled by CSS ::after pseudo-element */}\n    </div>\n  );\n};\n\nexport default BoardSquare;\n"],"names":[],"mappings":";;;;AAIA;AAEA;AALA;;;;AAkBA,MAAM,cAA0C,CAAC,EAC/C,MAAM,EACN,QAAQ,EACR,MAAM,EACN,UAAU,EACV,WAAW,EACX,iBAAiB,EACjB,aAAa,EACb,YAAY,EACb;IACC,MAAM,mBAAmB,SAAS,sBAAsB;IACxD,MAAM,iBAAiB,aAAa,2BAA2B;IAC/D,MAAM,iBAAiB,cAAc,4BAA4B;IAEjE,MAAM,cAAc;QAChB,IAAI,CAAC,QAAQ;YACT,cAAc;QAClB;IACA,iEAAiE;IACrE;IAEA,qBACE,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,gBAAgB,kBAAkB,gBAAgB;QAChE,SAAS;QACT,MAAK;QACL,iBAAe;QACf,cAAY,CAAC,cAAc,EAAE,SAAS,GAAG,GAAG,EAAE,SAAS,EAAE,SAAS,GAAG,GAAG,EAAE,EAAE,EAAE,SAAS,SAAS,UAAU,SAAS,CAAC,WAAW,EAAE,OAAO,MAAM,CAAC,MAAM,EAAE,OAAO,MAAM,GAAG,YAAY,IAAI,GAAG,YAAY,cAAc,wBAAwB,KAAK,qBAAqB,SAAS,8BAA8B,IAAI;kBAEhT,wBACC,8OAAC,kIAAA,CAAA,UAAY;YACX,OAAO;YACP,UAAU;YACV,YAAY;YACZ,mBAAmB;YACnB,SAAS;;;;;;;;;;;AAMnB;uCAEe","debugId":null}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,CAAA,GAAA,gKAAA,CAAA,MAAG,AAAD,EACvB,4VACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OAAO;YACP,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAC5B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO,EAAE;IACxD,MAAM,OAAO,UAAU,gKAAA,CAAA,OAAI,GAAG;IAC9B,qBACE,8OAAC;QACC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,eAAe;YAAE;YAAS;YAAM;QAAU;QACxD,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;AAEF,OAAO,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/alert.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAEA;;;;;AAEA,MAAM,gBAAgB,CAAA,GAAA,gKAAA,CAAA,MAAG,AAAD,EACtB,6JACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,MAAM,sBAAQ,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG3B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAO,EAAE,oBACnC,8OAAC;QACC,KAAK;QACL,MAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;AAGb,MAAM,WAAW,GAAG;AAEpB,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,iCAAmB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,iBAAiB,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n"],"names":[],"mappings":";;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG1B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,4DACA;QAED,GAAG,KAAK;;;;;;AAGb,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGrC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAI,KAAK;QAAK,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,YAAY;QAAa,GAAG,KAAK;;;;;;AAEhE,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/checkersLogic.ts"],"sourcesContent":["import type { Piece, Player, Board, Position, Move, GameState } from '@/types/checkers';\n\nexport const BOARD_SIZE = 8;\n\n// Initialize the board with pieces in starting positions\nexport function initializeBoard(): Board {\n  const board: Board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));\n\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      if ((row + col) % 2 !== 0) { // Only place pieces on dark squares\n        if (row < 3) {\n          board[row][col] = { player: 'dark', isKing: false };\n        } else if (row > 4) {\n          board[row][col] = { player: 'light', isKing: false };\n        }\n      }\n    }\n  }\n  return board;\n}\n\n// Check if a position is within the board boundaries\nexport function isWithinBoard(pos: Position): boolean {\n  return pos.row >= 0 && pos.row < BOARD_SIZE && pos.col >= 0 && pos.col < BOARD_SIZE;\n}\n\n// Check if a square is occupied by the opponent\nfunction isOpponent(board: Board, pos: Position, player: Player): boolean {\n  if (!isWithinBoard(pos)) return false;\n  const piece = board[pos.row][pos.col];\n  return piece !== null && piece.player !== player;\n}\n\n// Check if a square is empty\nfunction isEmpty(board: Board, pos: Position): boolean {\n   if (!isWithinBoard(pos)) return false;\n  return board[pos.row][pos.col] === null;\n}\n\n\n// Get possible moves for a piece (including captures)\nexport function getPossibleMoves(board: Board, from: Position, player: Player): Move[] {\n  const piece = board[from.row][from.col];\n  if (!piece || piece.player !== player) return [];\n\n  const moves: Move[] = [];\n  const captures: Move[] = [];\n  const directions = piece.isKing\n    ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] // King moves\n    : piece.player === 'light'\n    ? [[-1, -1], [-1, 1]] // Light normal moves (upwards)\n    : [[1, -1], [1, 1]]; // Dark normal moves (downwards)\n\n  // Check for captures first\n  for (const [dr, dc] of directions) {\n     const opponentPos = { row: from.row + dr, col: from.col + dc };\n     const landingPos = { row: from.row + 2 * dr, col: from.col + 2 * dc };\n\n     if (isWithinBoard(opponentPos) && isOpponent(board, opponentPos, player) && isWithinBoard(landingPos) && isEmpty(board, landingPos)) {\n        const capturedPiece = board[opponentPos.row][opponentPos.col];\n        if (capturedPiece) {\n           captures.push({ from, to: landingPos, captured: opponentPos });\n        }\n     }\n  }\n\n\n  // If captures are available, only capture moves are allowed\n   if (captures.length > 0) {\n     // Check for multi-captures recursively\n     const multiCaptures = checkMultiCaptures(board, from, player);\n     return multiCaptures.length > 0 ? multiCaptures : captures;\n   }\n\n   // If no captures, check for regular moves\n    for (const [dr, dc] of directions) {\n        const to = { row: from.row + dr, col: from.col + dc };\n        if (isWithinBoard(to) && isEmpty(board, to)) {\n           moves.push({ from, to });\n        }\n    }\n\n\n  return moves;\n}\n\n// Check for multi-jump possibilities recursively\nfunction checkMultiCaptures(board: Board, currentPos: Position, player: Player): Move[] {\n    const piece = board[currentPos.row]?.[currentPos.col]; // Add null check\n    if (!piece) return [];\n\n    const potentialCaptures: Move[] = [];\n    const directions = piece.isKing\n        ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]\n        : piece.player === 'light'\n        ? [[-1, -1], [-1, 1]]\n        : [[1, -1], [1, 1]];\n\n    for (const [dr, dc] of directions) {\n        const opponentPos = { row: currentPos.row + dr, col: currentPos.col + dc };\n        const landingPos = { row: currentPos.row + 2 * dr, col: currentPos.col + 2 * dc };\n\n        if (isWithinBoard(opponentPos) && isOpponent(board, opponentPos, player) && isWithinBoard(landingPos) && isEmpty(board, landingPos)) {\n            // Simulate the capture\n            const tempBoard = board.map(row => [...row]); // Deep copy\n            const movingPiece = tempBoard[currentPos.row][currentPos.col];\n            tempBoard[landingPos.row][landingPos.col] = movingPiece;\n            tempBoard[opponentPos.row][opponentPos.col] = null;\n            tempBoard[currentPos.row][currentPos.col] = null;\n\n            // Check for further captures from the landing position\n            const furtherCaptures = checkMultiCaptures(tempBoard, landingPos, player);\n\n            if (furtherCaptures.length > 0) {\n                // If further captures are possible, prepend the current capture to each path\n                furtherCaptures.forEach(fc => {\n                    potentialCaptures.push({\n                        from: currentPos,\n                        to: landingPos,\n                        captured: opponentPos,\n                        nextMoves: fc.nextMoves ? [fc] : [fc] // Ensure nextMoves is an array\n                    });\n                });\n            } else {\n                // This is the end of a capture sequence\n                potentialCaptures.push({ from: currentPos, to: landingPos, captured: opponentPos });\n            }\n        }\n    }\n\n    // We need to flatten the structure for the final list of possible starting moves\n    // This part is tricky. For the initial `getPossibleMoves` call, we only want the *first* jump.\n    // The UI will handle subsequent jumps based on the state after the first jump.\n    // So, let's just return the first-level captures found here.\n     const firstLevelCaptures = potentialCaptures.map(capture => ({\n        from: capture.from,\n        to: capture.to,\n        captured: capture.captured\n     }));\n\n     return firstLevelCaptures; // Return only the first jump possibilities from this position\n}\n\n\n// Apply a move to the board state\nexport function applyMove(board: Board, move: Move): Board {\n  const newBoard = board.map(row => [...row]); // Deep copy\n  const piece = newBoard[move.from.row][move.from.col];\n\n  if (!piece) return board; // Should not happen if move is valid\n\n  // Move the piece\n  newBoard[move.to.row][move.to.col] = piece;\n  newBoard[move.from.row][move.from.col] = null;\n\n  // Remove captured piece\n  if (move.captured) {\n    newBoard[move.captured.row][move.captured.col] = null;\n  }\n\n   // Check for crowning\n   const targetRow = piece.player === 'light' ? 0 : BOARD_SIZE - 1;\n   if (move.to.row === targetRow && !piece.isKing) {\n     newBoard[move.to.row][move.to.col] = { ...piece, isKing: true };\n   }\n\n\n  return newBoard;\n}\n\n\n// Check if a player has any possible moves left\nexport function hasMoves(board: Board, player: Player): boolean {\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      const piece = board[r][c];\n      if (piece && piece.player === player) {\n        const moves = getPossibleMoves(board, { row: r, col: c }, player);\n        if (moves.length > 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// Check if a player has any pieces left\nexport function hasPieces(board: Board, player: Player): boolean {\n  for (let r = 0; r < BOARD_SIZE; r++) {\n    for (let c = 0; c < BOARD_SIZE; c++) {\n      if (board[r][c]?.player === player) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// Determine if the game is over and who won\nexport function checkWinner(board: Board, currentPlayer: Player): Player | 'draw' | null {\n    const opponent: Player = currentPlayer === 'light' ? 'dark' : 'light';\n\n    const currentPlayerHasMoves = hasMoves(board, currentPlayer);\n    const opponentHasMoves = hasMoves(board, opponent);\n    const currentPlayerHasPieces = hasPieces(board, currentPlayer);\n    const opponentHasPieces = hasPieces(board, opponent);\n\n\n    if (!currentPlayerHasPieces || !currentPlayerHasMoves) {\n        return opponent; // Current player cannot move or has no pieces, opponent wins\n    }\n    if (!opponentHasPieces || !opponentHasMoves) {\n        return currentPlayer; // Opponent cannot move or has no pieces, current player wins\n    }\n\n    // Draw condition (optional, e.g., based on move count without capture)\n    // For simplicity, we'll omit draw conditions for now.\n\n    return null; // Game is not over\n}\n\n\n// Check if any capture moves are available for the current player\nexport function mustCapture(board: Board, player: Player): boolean {\n   for (let r = 0; r < BOARD_SIZE; r++) {\n       for (let c = 0; c < BOARD_SIZE; c++) {\n           const piece = board[r][c];\n           if (piece && piece.player === player) {\n               const moves = getPossibleMoves(board, { row: r, col: c }, player);\n               if (moves.some(move => move.captured)) {\n                   return true;\n               }\n           }\n       }\n   }\n   return false;\n}\n\n// Get only the capture moves available for a player\nexport function getCaptureMoves(board: Board, player: Player): Move[] {\n    const captureMoves: Move[] = [];\n    for (let r = 0; r < BOARD_SIZE; r++) {\n        for (let c = 0; c < BOARD_SIZE; c++) {\n            const piece = board[r][c];\n            if (piece && piece.player === player) {\n                const moves = getPossibleMoves(board, { row: r, col: c }, player);\n                moves.forEach(move => {\n                    if (move.captured) {\n                        captureMoves.push(move);\n                    }\n                });\n            }\n        }\n    }\n    return captureMoves;\n}\n\n\n// Check if a specific piece has further captures available after a capture move\nexport function canContinueCapture(board: Board, pos: Position, player: Player): boolean {\n    const piece = board[pos.row][pos.col];\n    if (!piece || piece.player !== player) return false;\n\n    const directions = piece.isKing\n        ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]\n        : piece.player === 'light'\n        ? [[-1, -1], [-1, 1]]\n        : [[1, -1], [1, 1]];\n\n    for (const [dr, dc] of directions) {\n        const opponentPos = { row: pos.row + dr, col: pos.col + dc };\n        const landingPos = { row: pos.row + 2 * dr, col: pos.col + 2 * dc };\n\n        if (isWithinBoard(opponentPos) && isOpponent(board, opponentPos, player) && isWithinBoard(landingPos) && isEmpty(board, landingPos)) {\n           return true; // Found a possible next capture\n        }\n    }\n    return false;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 716, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/CheckersBoard.tsx"],"sourcesContent":["\n'use client';\n\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { RefreshCw, Undo } from 'lucide-react';\nimport BoardSquare from './BoardSquare';\nimport { Button } from '@/components/ui/button';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport type { Board, Position, Move, GameState, Player } from '@/types/checkers';\nimport {\n    initializeBoard,\n    getPossibleMoves,\n    applyMove,\n    checkWinner,\n    BOARD_SIZE,\n    mustCapture,\n    canContinueCapture,\n    getCaptureMoves\n} from '@/lib/checkersLogic';\nimport { cn } from '@/lib/utils';\n\nconst initialGameState: GameState = {\n  board: initializeBoard(),\n  currentPlayer: 'light',\n  selectedPiece: null,\n  possibleMoves: [],\n  winner: null,\n  isMultiCapture: false,\n  mustCapturePiece: null,\n};\n\nconst CheckersBoard: React.FC = () => {\n  const [gameState, setGameState] = useState<GameState>(initialGameState);\n  const [history, setHistory] = useState<GameState[]>([]); // For undo functionality\n  const [forcedCapturePieceInfo, setForcedCapturePieceInfo] = useState<Position | null>(null);\n\n   // Reset game to initial state\n   const resetGame = useCallback(() => {\n       setGameState(initialGameState);\n       setHistory([]);\n       setForcedCapturePieceInfo(null);\n   }, []);\n\n  // Save current state to history\n   const saveHistory = useCallback((state: GameState) => {\n       setHistory(prev => [...prev, state]);\n   }, []);\n\n   // Undo the last move\n   const undoMove = useCallback(() => {\n       setHistory(prev => {\n           const lastStateArray = prev.slice(0, -1);\n           const newState = lastStateArray[lastStateArray.length - 1] || initialGameState;\n           setGameState(newState);\n           return lastStateArray;\n       });\n   }, []);\n\n  useEffect(() => {\n    if (gameState.winner) {\n      setForcedCapturePieceInfo(null);\n      return;\n    }\n\n    if (gameState.isMultiCapture && gameState.mustCapturePiece) {\n      setForcedCapturePieceInfo(gameState.mustCapturePiece);\n    } else {\n      const mandatory = mustCapture(gameState.board, gameState.currentPlayer);\n      if (mandatory) {\n        const board = gameState.board;\n        const player = gameState.currentPlayer;\n        let pieceToHighlight: Position | null = null;\n        for (let r = 0; r < BOARD_SIZE; r++) {\n          for (let c = 0; c < BOARD_SIZE; c++) {\n            const currentPiecePos = { row: r, col: c };\n            const piece = board[r][c];\n            if (piece && piece.player === player) {\n              const moves = getPossibleMoves(board, currentPiecePos, player);\n              if (moves.some(move => move.captured)) {\n                pieceToHighlight = currentPiecePos;\n                break; \n              }\n            }\n          }\n          if (pieceToHighlight) break;\n        }\n        setForcedCapturePieceInfo(pieceToHighlight);\n      } else {\n        setForcedCapturePieceInfo(null);\n      }\n    }\n  }, [gameState.board, gameState.currentPlayer, gameState.winner, gameState.isMultiCapture, gameState.mustCapturePiece]);\n\n\n  const handlePieceClick = useCallback((pos: Position) => {\n      const { board, currentPlayer, selectedPiece, isMultiCapture, mustCapturePiece } = gameState;\n      const piece = board[pos.row][pos.col];\n\n      if (isMultiCapture && mustCapturePiece && (pos.row !== mustCapturePiece.row || pos.col !== mustCapturePiece.col)) {\n          return;\n      }\n\n      if (!piece || piece.player !== currentPlayer) {\n        setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n        return;\n      }\n\n      const captureIsMandatory = mustCapture(board, currentPlayer);\n      const availableMoves = getPossibleMoves(board, pos, currentPlayer);\n\n      const validMoves = captureIsMandatory\n          ? availableMoves.filter(move => move.captured)\n          : availableMoves;\n\n      if (!isMultiCapture && selectedPiece && selectedPiece.row === pos.row && selectedPiece.col === pos.col) {\n          setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n      } else if (validMoves.length > 0) {\n          if (!captureIsMandatory || validMoves.some(m => m.from.row === pos.row && m.from.col === pos.col)) {\n              setGameState(prev => ({\n                  ...prev,\n                  selectedPiece: pos,\n                  possibleMoves: validMoves.filter(m => m.from.row === pos.row && m.from.col === pos.col)\n              }));\n          } else {\n             setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n          }\n      } else {\n         if (!isMultiCapture) {\n            setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n         }\n      }\n\n  }, [gameState]);\n\n   const handleSquareClick = useCallback((pos: Position) => {\n       const { selectedPiece, possibleMoves, board, currentPlayer, isMultiCapture } = gameState;\n\n       if (!selectedPiece) return;\n\n       const move = possibleMoves.find(m => m.to.row === pos.row && m.to.col === pos.col);\n\n       if (move) {\n           saveHistory(gameState); \n\n           const newBoard = applyMove(board, move);\n           const wasCapture = !!move.captured;\n           let nextPlayer = currentPlayer === 'light' ? 'dark' : 'light';\n           let continueCapture = false;\n           let nextMustCapturePiece = null;\n\n           if (wasCapture && canContinueCapture(newBoard, move.to, currentPlayer)) {\n               const furtherCaptures = getCaptureMoves(newBoard, currentPlayer).filter(m => m.from.row === move.to.row && m.from.col === move.to.col);\n               if (furtherCaptures.length > 0) {\n                  nextPlayer = currentPlayer; \n                  continueCapture = true;\n                  nextMustCapturePiece = move.to; \n               }\n           }\n\n           const winner = checkWinner(newBoard, nextPlayer);\n\n           setGameState({\n               board: newBoard,\n               currentPlayer: nextPlayer,\n               selectedPiece: continueCapture ? move.to : null,\n               possibleMoves: continueCapture ? getPossibleMoves(newBoard, move.to, currentPlayer).filter(m => m.captured) : [],\n               winner: winner,\n               isMultiCapture: continueCapture,\n               mustCapturePiece: nextMustCapturePiece,\n           });\n\n       } else {\n            if (!isMultiCapture) {\n               setGameState(prev => ({ ...prev, selectedPiece: null, possibleMoves: [] }));\n            }\n       }\n   }, [gameState, saveHistory]);\n\n\n  useEffect(() => {\n    // This effect can be used for side-effects when a turn starts and mandatory capture is detected,\n    // but the main logic for highlighting is now in the other useEffect.\n    if (!gameState.isMultiCapture && !gameState.winner) {\n        const captureIsMandatory = mustCapture(gameState.board, gameState.currentPlayer);\n        if (captureIsMandatory) {\n            // console.log(\"Capture is mandatory for player:\", gameState.currentPlayer);\n        }\n    }\n  }, [gameState.currentPlayer, gameState.board, gameState.isMultiCapture, gameState.winner]);\n\n\n  return (\n    <div className=\"flex flex-col items-center p-4 md:p-8 min-h-screen bg-background text-foreground\">\n      <div className=\"flex flex-col lg:flex-row gap-8 w-full max-w-6xl\">\n        {/* Left Panel: Game Title, Status & Info */}\n        <div className=\"lg:w-72 w-full flex-shrink-0 order-2 lg:order-1 flex flex-col gap-6\">\n          <h1 className=\"text-4xl font-bold text-center lg:text-left\">Checkered</h1>\n          \n          {gameState.winner && (\n            <Alert variant={gameState.winner === 'draw' ? 'default' : 'destructive'} className={gameState.winner !== 'draw' ? \"bg-accent text-accent-foreground\" : \"\"}>\n              <AlertTitle className=\"font-bold text-lg\">Game Over!</AlertTitle>\n              <AlertDescription>\n                {gameState.winner === 'draw' ? 'The game is a draw!' : `Player ${gameState.winner === 'light' ? 'Light (Gray)' : 'Dark (Red)'} wins!`}\n              </AlertDescription>\n            </Alert>\n          )}\n\n          {!gameState.winner && (\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-xl text-center lg:text-left\">Current Turn</CardTitle>\n              </CardHeader>\n              <CardContent className=\"flex flex-col items-center lg:items-start gap-2\">\n                <span className={cn(\n                  \"px-4 py-2 rounded-md text-lg font-semibold\",\n                  gameState.currentPlayer === 'light' ? 'bg-piece-light text-black' : 'bg-piece-dark text-white'\n                )}>\n                  {gameState.currentPlayer === 'light' ? 'Light (Gray)' : 'Dark (Red)'}\n                </span>\n                {(gameState.isMultiCapture || (forcedCapturePieceInfo && !gameState.selectedPiece)) && (\n                  <span className=\"text-sm text-destructive font-medium\">(Must capture)</span>\n                )}\n              </CardContent>\n            </Card>\n          )}\n\n          <Card className=\"mt-auto\">\n             <CardHeader>\n               <CardTitle className=\"text-lg text-center lg:text-left\">Game Controls</CardTitle>\n             </CardHeader>\n             <CardContent className=\"flex flex-col gap-3\">\n                <Button onClick={resetGame} variant=\"outline\" className=\"w-full\">\n                  <RefreshCw className=\"mr-2 h-4 w-4\" /> Reset Game\n                </Button>\n                <Button onClick={undoMove} variant=\"outline\" disabled={history.length === 0 || gameState.winner !== null} className=\"w-full\">\n                  <Undo className=\"mr-2 h-4 w-4\" /> Undo Move\n                </Button>\n             </CardContent>\n          </Card>\n        </div>\n\n        {/* Right Panel: Checkers Board */}\n        <div className=\"flex-grow flex justify-center items-start order-1 lg:order-2\">\n          <div\n            className=\"grid grid-cols-8 border-4 border-gray-800 shadow-xl\"\n            style={{ width: 'fit-content' }}\n            role=\"grid\"\n            aria-label=\"Checkers board\"\n          >\n            {gameState.board.map((row, rowIndex) =>\n              row.map((square, colIndex) => {\n                const pos = { row: rowIndex, col: colIndex };\n                const isDark = (rowIndex + colIndex) % 2 !== 0;\n                const isSelected = gameState.selectedPiece?.row === rowIndex && gameState.selectedPiece?.col === colIndex;\n                const isValidMove = gameState.possibleMoves.some(move => move.to.row === rowIndex && move.to.col === colIndex);\n                const isForcedToCapturePiece = forcedCapturePieceInfo?.row === rowIndex && forcedCapturePieceInfo?.col === colIndex;\n\n                return (\n                  <BoardSquare\n                    key={`${rowIndex}-${colIndex}`}\n                    square={square}\n                    position={pos}\n                    isDark={isDark}\n                    isSelected={isSelected}\n                    isValidMove={isValidMove}\n                    isForcedToCapture={isForcedToCapturePiece}\n                    onSquareClick={handleSquareClick}\n                    onPieceClick={handlePieceClick}\n                  />\n                );\n              })\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CheckersBoard;\n"],"names":[],"mappings":"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","debugId":null}}]
}